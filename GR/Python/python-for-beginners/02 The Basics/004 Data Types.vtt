WEBVTT

1
00:00:05.020 --> 00:00:05.610
Welcome back.

2
00:00:05.610 --> 00:00:08.240
I'm Alex Bowers from Learntoprogram.tv,
and in this video I'll be

3
00:00:08.240 --> 00:00:12.430
showing you the different data types that
there are within Python.

4
00:00:12.430 --> 00:00:15.080
Well, the most important ones at least
anyways.

5
00:00:15.080 --> 00:00:19.250
So the first one we've already roughly
seen is numbers, where there is

6
00:00:19.250 --> 00:00:25.180
two types of number data types, and that
is an integer and a float.

7
00:00:25.180 --> 00:00:26.620
Now, if you've done any programming in any
other

8
00:00:26.620 --> 00:00:31.130
languages you've might have heard float
being called a double.

9
00:00:31.130 --> 00:00:34.610
It's the same thing as just when it has a
floating decimal point.

10
00:00:34.610 --> 00:00:40.610
So, this will be an integer, number 42,
number 50, number 120.

11
00:00:40.610 --> 00:00:41.810
They're all integers.

12
00:00:41.810 --> 00:00:46.300
But as soon as it has a decimal point, it
becomes a float.

13
00:00:46.300 --> 00:00:49.390
And I will show this by just quickly doing
a

14
00:00:49.390 --> 00:00:54.530
is equal to 50, and then I will do type A.

15
00:00:54.530 --> 00:00:55.470
And I need to print out.

16
00:00:58.330 --> 00:01:00.450
And inside the print, if we actually do a

17
00:01:00.450 --> 00:01:04.620
comma, it allows us to do another print as
well.

18
00:01:04.620 --> 00:01:09.860
And so if we do type a,a it'll allow us to
see the type and then the value of that.

19
00:01:09.860 --> 00:01:14.375
So if we save that it's [UNKNOWN], you'll
see at the

20
00:01:14.375 --> 00:01:18.890
bottom we get a class of integer and a
value of 50.

21
00:01:18.890 --> 00:01:24.180
So if I was to add a 50.0 even though the
actual value hasn't changed.

22
00:01:24.180 --> 00:01:27.090
The way it's represented is changed, and
it's now called a float.

23
00:01:27.090 --> 00:01:31.280
And a float is a decimal is something
which has a decimal point.

24
00:01:32.890 --> 00:01:38.730
Now, there are a couple of things that you
can do with with a float and integers

25
00:01:38.730 --> 00:01:40.350
which are different, which is why you
might

26
00:01:40.350 --> 00:01:44.200
need something in particular from one way
or another.

27
00:01:44.200 --> 00:01:47.820
But I will go over those later on within
the course.

28
00:01:47.820 --> 00:01:50.830
The main thing that you should know at the
moment is that

29
00:01:50.830 --> 00:01:55.490
the two different types exist but they do
have different meanings and purposes.

30
00:01:55.490 --> 00:01:58.560
And also that you can convert one to the
other.

31
00:01:58.560 --> 00:02:00.530
So, for example, if we wanted one to be

32
00:02:00.530 --> 00:02:03.445
an integer, we'd do an int function around
it.

33
00:02:03.445 --> 00:02:05.210
This is called type casting.

34
00:02:05.210 --> 00:02:11.164
And what you do then is you type 50.0
inside there.

35
00:02:11.164 --> 00:02:17.370
And if you run that, you'll get an integer
of 50, and that just rounds it off.

36
00:02:17.370 --> 00:02:21.430
It cuts off any decimal points even if
it's 0.9, it will

37
00:02:21.430 --> 00:02:26.140
round it down to 50 because it doesn't
take into effect rounding.

38
00:02:26.140 --> 00:02:29.190
If you wanted to do that you'd have to use
the function round.

39
00:02:29.190 --> 00:02:33.416
Which would then, there you go, it would
now run it

40
00:02:33.416 --> 00:02:38.250
and convert that to 51 cuz it's close to
51 than 50.

41
00:02:38.250 --> 00:02:41.620
So there are maths functions, or math
functions, available which

42
00:02:41.620 --> 00:02:44.690
we will be covering later on again in the
course.

43
00:02:44.690 --> 00:02:48.070
But, because you can do the typecasting of
integer,

44
00:02:48.070 --> 00:02:50.870
that also means you can do the typecasting
of float.

45
00:02:50.870 --> 00:02:55.780
So, if you were to have 50.9, and when
that, it would stay at 50.9.

46
00:02:55.780 --> 00:03:02.390
If you were to get rid of those two
digits, it'd come up as 50.0.

47
00:03:02.390 --> 00:03:08.630
So, now that you can type cast between
floating

48
00:03:08.630 --> 00:03:15.730
integer, you can, con, control the way in
which the application runs.

49
00:03:15.730 --> 00:03:18.280
Which is quite a useful thing to have.

50
00:03:18.280 --> 00:03:23.710
Now the next type of data that we're going
to be using is also is called a string.

51
00:03:23.710 --> 00:03:26.760
And so, the way you represent a string is
by using either

52
00:03:26.760 --> 00:03:29.382
two single quotes, one at the beginning
and one at the end.

53
00:03:29.382 --> 00:03:32.160
Or two double quotes, one at the
beginning, one at the end.

54
00:03:33.480 --> 00:03:35.930
Now it must be the same type of quotes at
the beginning and

55
00:03:35.930 --> 00:03:40.990
at the end, so it can tell what the actual
content between it is.

56
00:03:40.990 --> 00:03:42.770
And so, this is a string.

57
00:03:42.770 --> 00:03:46.360
As you can see, if I was to run this, you
get a class

58
00:03:46.360 --> 00:03:49.960
of str which stands for string, and the
output is this is a string.

59
00:03:51.500 --> 00:03:58.360
Now before I mentioned that you need to
use one of each quote at each end.

60
00:03:58.360 --> 00:04:02.548
However, there is a way in which you can
do triple quotes, which allows you to do

61
00:04:02.548 --> 00:04:11.520
multi-line text, and so this is a string,
would print it out over three lines.

62
00:04:11.520 --> 00:04:14.550
So, there you can see this is a string is
a class.

63
00:04:14.550 --> 00:04:20.170
If I just remove the type from there, it
recognizes these as a string even

64
00:04:20.170 --> 00:04:23.780
though you are using a different way of
representing it, it is still a string.

65
00:04:23.780 --> 00:04:28.600
You'll notice that we have, it has this
tab from inside, and that's

66
00:04:28.600 --> 00:04:33.840
because it follows the exact formatting
that it has within this string over here.

67
00:04:33.840 --> 00:04:37.940
But also you'll notice it has an extra
line at the top, which you might not want.

68
00:04:37.940 --> 00:04:40.830
The way you can get rid of that is
something called escaping.

69
00:04:40.830 --> 00:04:45.900
What you do is you add a backslash as the
last character on the string, on the 1st

70
00:04:45.900 --> 00:04:51.920
line, or the last character on any line,
it'll have the same effect.

71
00:04:51.920 --> 00:04:54.500
And what it does is it escapes the actual,

72
00:04:57.170 --> 00:05:01.450
escapes the actual character that follows
it.

73
00:05:01.450 --> 00:05:03.010
And there is a character here, which

74
00:05:03.010 --> 00:05:06.190
is invisible and it's the paragraph
character,

75
00:05:06.190 --> 00:05:10.030
which it looks sort of like a backwards p
with two lines going down.

76
00:05:10.030 --> 00:05:13.150
That's the sort of character which is
invisible but it is

77
00:05:13.150 --> 00:05:15.630
saved there, and that's what makes it have
a new line.

78
00:05:16.970 --> 00:05:19.910
And so, likewise if I was to put a
backslash on here

79
00:05:20.930 --> 00:05:25.060
and run this, we would get this a string
on the same line.

80
00:05:25.060 --> 00:05:27.230
So, as you can see, all it does is control

81
00:05:29.360 --> 00:05:31.360
well, escape certain characters.

82
00:05:32.680 --> 00:05:35.530
Now, you can do this with either single or
double quotes,

83
00:05:35.530 --> 00:05:38.650
and again it must be the same if beginning
and the end.

84
00:05:38.650 --> 00:05:41.480
Although it is much cleaner to look at to
use

85
00:05:41.480 --> 00:05:44.340
single quotes than double quotes, because
that just looks more untidy.

86
00:05:44.340 --> 00:05:46.590
Because there's more lines going down.

87
00:05:47.850 --> 00:05:50.810
Okay, the next thing that we're going to
have to look at.

88
00:05:51.820 --> 00:05:56.850
Is the fact that you can't escape multiple
different things.

89
00:05:56.850 --> 00:05:58.770
I'll get back to using single line strings
for now.

90
00:06:00.540 --> 00:06:03.000
So, this is a string.

91
00:06:03.000 --> 00:06:08.412
If I wanted to have a new line, what you
have to do is backward slash n.

92
00:06:08.412 --> 00:06:14.430
And what backward slash n is a special
escape character which refers to

93
00:06:16.590 --> 00:06:20.180
making a new line, the invisible paragraph
sign.

94
00:06:20.180 --> 00:06:22.660
And so when you run this you get this as a
string.

95
00:06:22.660 --> 00:06:26.280
But if you were to actually want to have
slash n, backward

96
00:06:26.280 --> 00:06:30.740
slash n within your content, you need to
convert into a raw string.

97
00:06:30.740 --> 00:06:34.460
Because obviously, this is being processes
as being a special character.

98
00:06:34.460 --> 00:06:38.740
But there might be an occasion when you
want to actually output slash n.

99
00:06:38.740 --> 00:06:40.430
The way you do that is to convert it into

100
00:06:40.430 --> 00:06:42.690
a raw string by putting an r in front of
it.

101
00:06:44.110 --> 00:06:45.570
And now you'll get this is r.

102
00:06:46.750 --> 00:06:47.620
I'm sorry, that's not right.

103
00:06:54.710 --> 00:06:55.320
There we go.

104
00:06:55.320 --> 00:06:58.390
You need to an end of backslash to it, and

105
00:06:58.390 --> 00:07:04.020
that will convert it into a vosh, a var
escaped character.

106
00:07:04.020 --> 00:07:08.985
And what you do there is you have you now
get the output of slash n.

107
00:07:08.985 --> 00:07:13.410
And what that backwards slash there does
is it escapes the one

108
00:07:13.410 --> 00:07:18.530
after it, so you have two backwards
slashes will escape the backwards slash.

109
00:07:18.530 --> 00:07:21.340
And that backward slash no longer escapes
the n.

110
00:07:21.340 --> 00:07:23.120
So now you end up with just slash n.

111
00:07:23.120 --> 00:07:25.490
If you're confused by that, don't worry
too much.

112
00:07:25.490 --> 00:07:28.670
It's a simple, sort of concept, and you
will

113
00:07:28.670 --> 00:07:31.618
learn more about it as we progress
throughout the course.

114
00:07:31.618 --> 00:07:40.400
Okay the, there is another very

115
00:07:40.400 --> 00:07:45.740
useful thing which you use within string,
and that is to add extra data to it.

116
00:07:45.740 --> 00:07:50.410
So, we're going to add another, another
variable and

117
00:07:50.410 --> 00:07:54.170
we're call this one, just put "Hello"
within it.

118
00:07:55.340 --> 00:07:57.980
And what you'll see is

119
00:08:00.100 --> 00:08:02.555
this is the old way of doing it and you
use a

120
00:08:02.555 --> 00:08:09.330
%s, and afterwards you put a percent and
then the actual letter.

121
00:08:09.330 --> 00:08:11.520
So I'll change that letter just to make it
more obvious.

122
00:08:11.520 --> 00:08:12.350
I'll call that b.

123
00:08:15.000 --> 00:08:16.500
And if you run this.

124
00:08:16.500 --> 00:08:18.270
You'll see that this is hello a string,
which is

125
00:08:18.270 --> 00:08:22.560
what you'd expect to happen because that
%s there stands

126
00:08:22.560 --> 00:08:26.510
for a string input and %b just shows that
we're

127
00:08:26.510 --> 00:08:30.420
using, what that percent is and we're
using the variable b.

128
00:08:30.420 --> 00:08:34.903
The percent sign is just a way to
reference that we are

129
00:08:34.903 --> 00:08:41.490
finding an input from somewhere else
within the script and they are variable.

130
00:08:41.490 --> 00:08:44.030
There is another use for percentage which
we will get into when

131
00:08:44.030 --> 00:08:47.810
we go into arithmetic, see arithmetic

132
00:08:47.810 --> 00:08:50.950
operators which is simply called modulus
function.

133
00:08:50.950 --> 00:08:55.460
But we'll move onto that later on when we
get more back into numbers again.

134
00:08:56.860 --> 00:09:01.870
But as I mentioned, this the old way of
doing it, and there is a much newer

135
00:09:01.870 --> 00:09:07.020
way which is within 3.2 of my career 3.1.

136
00:09:07.020 --> 00:09:12.430
But came in with 3.7, and it is the way
Python is heading towards.

137
00:09:12.430 --> 00:09:15.070
And this way is kind of obsolete, and it's

138
00:09:15.070 --> 00:09:20.230
going to be removed within the next
version or two.

139
00:09:20.230 --> 00:09:23.570
So, it's probably best not to use this
method, although I just showed you

140
00:09:23.570 --> 00:09:27.040
it just so you can see the difference
between the old and the new.

141
00:09:27.040 --> 00:09:29.130
Cuz if you see any code online, you'll see

142
00:09:29.130 --> 00:09:33.340
it most likely the old method, which is
this method.

143
00:09:33.340 --> 00:09:36.630
The new, oh, it's worth noting that, say,
if I was to replace

144
00:09:36.630 --> 00:09:41.410
this with an I then that would put an
integer, and so on.

145
00:09:41.410 --> 00:09:43.490
And an f, for float.

146
00:09:43.490 --> 00:09:47.020
A b for, boolean, which I'll cover in a
second.

147
00:09:47.020 --> 00:09:51.560
And a d, for dictionary, which I'll cover,
again, in a few minutes.

148
00:09:51.560 --> 00:09:56.680
So, the new way of doing this is what you
do is add curly braces.

149
00:09:56.680 --> 00:09:59.660
The curly braces are next to the return
key, and

150
00:09:59.660 --> 00:10:02.850
you have to do shift and then open and
close it.

151
00:10:02.850 --> 00:10:08.190
And what you have to do now is format,
which is just a function which.

152
00:10:08.190 --> 00:10:11.020
Append something, or insert something into
the

153
00:10:11.020 --> 00:10:14.680
string where ever the curly brackets are.

154
00:10:14.680 --> 00:10:18.410
And if we were to run this now, you'll see
we get the exact same output.

155
00:10:19.830 --> 00:10:22.140
However, this is the new way of doing it,
and this is the way

156
00:10:22.140 --> 00:10:27.410
in which you should be doing inserting
data into a string from now on.

157
00:10:27.410 --> 00:10:30.180
The way in which this would be considered
useful is

158
00:10:30.180 --> 00:10:32.972
if you were taking input from a user then
you

159
00:10:32.972 --> 00:10:36.865
could output a certain value from a
function, or you

160
00:10:36.865 --> 00:10:41.350
could output a certain value based on what
they put.

161
00:10:41.350 --> 00:10:47.647
So if they were to insert then [UNKNOWN]
for example, how to use the name

162
00:10:47.647 --> 00:10:53.870
Alex, and an application might say
something like welcome.

163
00:10:53.870 --> 00:10:57.230
That would do there, is it announcing it
welcome Alex, for example.

164
00:10:57.230 --> 00:10:59.820
So that is the sort of idea behind it.

165
00:10:59.820 --> 00:11:04.100
And that is what we will be using it for
most of the time.

166
00:11:05.720 --> 00:11:10.690
Now there's also another

167
00:11:10.690 --> 00:11:17.290
couple of data types which are sort of
related to

168
00:11:17.290 --> 00:11:21.180
an array, which, if you don't know what an
array is, don't worry about it too much.

169
00:11:21.180 --> 00:11:25.100
It's called a list in Python, which sort
of

170
00:11:25.100 --> 00:11:27.960
describes it more closely to what it
actually is.

171
00:11:29.860 --> 00:11:35.630
And so there's two types of lists, one's
called a tuple and one's called a list.

172
00:11:35.630 --> 00:11:42.790
And a tuple you define using the paren,
parenthesis, and how you define it

173
00:11:42.790 --> 00:11:49.340
is by putting any variable name is equal
to and then open and close the brackets.

174
00:11:49.340 --> 00:11:51.460
Then just do one, two, three, four, five.

175
00:11:53.270 --> 00:11:56.020
And to separate each file you just put
comma between it.

176
00:11:56.020 --> 00:12:05.090
And what you'll see I'll just do print,
type XX, and there you'll

177
00:12:05.090 --> 00:12:09.559
see its the class of the tuple and you the
values of one ,two, three, four and five.

178
00:12:10.560 --> 00:12:17.000
Now, there is a function called append,
where

179
00:12:17.000 --> 00:12:18.940
where you can append a value to a list.

180
00:12:20.260 --> 00:12:25.220
However, with a tuple, is it doesn't
exist.

181
00:12:25.220 --> 00:12:27.290
Because a tuple can not be modified.

182
00:12:28.460 --> 00:12:31.770
It is declared once, and then that is all
it can be kept at.

183
00:12:31.770 --> 00:12:35.200
So it was similar to a constant really.

184
00:12:37.120 --> 00:12:42.020
However, if you wanted to change
something, what you would use is you

185
00:12:42.020 --> 00:12:47.040
would use something called a list which is
declared by using square brackets.

186
00:12:47.040 --> 00:12:48.800
And if you to run this you would get a
class of

187
00:12:48.800 --> 00:12:51.880
the list and square brackets of one, two,
three, four, and five.

188
00:12:52.930 --> 00:12:55.370
Now, if we were to add back in that append

189
00:12:55.370 --> 00:12:59.170
function, you'll now get one, two, three,
four, five and six.

190
00:12:59.170 --> 00:13:01.500
So, there is different uses between the
two.

191
00:13:01.500 --> 00:13:05.420
But the main difference is that one of
them can modify and one can't.

192
00:13:05.420 --> 00:13:09.680
If you can't modify something, then you're
less likely to make a mistake with it.

193
00:13:09.680 --> 00:13:11.540
So if you don't need to modify something,
it's better

194
00:13:11.540 --> 00:13:14.170
to use a tuple than it is to use a list.

195
00:13:14.170 --> 00:13:16.060
Because using a two pole, if you were to

196
00:13:16.060 --> 00:13:18.730
try and modify it, and when you weren't
meant to,

197
00:13:18.730 --> 00:13:21.230
for example, then it would throw that over
and

198
00:13:21.230 --> 00:13:24.300
you'd be able to find out where your
problem was.

199
00:13:24.300 --> 00:13:26.520
Whereas a list As you see cuz it allows

200
00:13:26.520 --> 00:13:30.410
you to insert and append and prepend and
so on.

201
00:13:30.410 --> 00:13:34.340
It would allow you to continue without

202
00:13:34.340 --> 00:13:35.990
knowing that you've made mistakes and
where.

203
00:13:35.990 --> 00:13:40.680
In which case, it might actually break
your application, for example.

204
00:13:42.700 --> 00:13:51.980
Okay, and now that we've covered both of
list and both the list and the tables.

205
00:13:51.980 --> 00:13:54.040
There are a couple of things in which are

206
00:13:54.040 --> 00:13:58.515
special, with lists which you can't do
within a tuple.

207
00:14:00.030 --> 00:14:02.150
And that is to declare a certain

208
00:14:04.470 --> 00:14:11.000
memory location within a loss in, a
certain index within the within the list.

209
00:14:11.000 --> 00:14:14.560
And you do that by using the square
brackets and the index value.

210
00:14:14.560 --> 00:14:17.530
And the index value here is three.

211
00:14:17.530 --> 00:14:19.090
However, we inserted a number two.

212
00:14:19.090 --> 00:14:23.120
And if you look up here, number three is
the third one across.

213
00:14:23.120 --> 00:14:27.010
And the reason for that is that a list is
indexed starting at zero.

214
00:14:27.010 --> 00:14:28.510
So, this has an index of zero.

215
00:14:28.510 --> 00:14:30.010
This has an index of one.

216
00:14:30.010 --> 00:14:32.070
And this here has an index of two.

217
00:14:32.070 --> 00:14:35.280
We're referencing the index of two, so
that's why we get the value of three back.

218
00:14:37.270 --> 00:14:42.210
The next thing in which you may find
useful, and we'll cover later on is

219
00:14:42.210 --> 00:14:48.810
something called Well, it's where you can
select a value within a range.

220
00:14:48.810 --> 00:14:54.190
So if I was to go two to four, you'd get
these values.

221
00:14:54.190 --> 00:14:56.020
You'd get a three and four.

222
00:14:56.020 --> 00:14:58.480
Now the reason why we don't get, cuz
remember

223
00:14:58.480 --> 00:15:01.380
indexes start at zero, so it goes zero,
one, two.

224
00:15:01.380 --> 00:15:04.800
So we select that value, that's the second
one.

225
00:15:04.800 --> 00:15:07.000
And now we're going towards four.

226
00:15:07.000 --> 00:15:10.740
However, three and four, you'd expect it
to return the value three, four, five.

227
00:15:10.740 --> 00:15:13.780
But we're only returning the three, four.

228
00:15:13.780 --> 00:15:18.840
And the reason for that is that final
actual number doesn't get found.

229
00:15:18.840 --> 00:15:20.825
If we were to change that value there to

230
00:15:20.825 --> 00:15:23.820
five, then it would select it and it would
work.

231
00:15:25.300 --> 00:15:29.530
And also the rest of your method with
which you remove

232
00:15:29.530 --> 00:15:32.940
the final number and it'll select from two
towards the end.

233
00:15:32.940 --> 00:15:38.250
And if I were to change that to four and
remove the first number, it would

234
00:15:38.250 --> 00:15:43.520
select, things up until the fourth index
or the third index.

235
00:15:45.940 --> 00:15:50.920
So, from there, we'll be covering this in
more detail later on, and I'll be

236
00:15:50.920 --> 00:15:57.370
explaining, certain uses for this
construction idea.

237
00:15:57.370 --> 00:16:01.650
However, that is a very useful and
powerful tool while using listings.

238
00:16:03.600 --> 00:16:06.075
The next thing that we have is something
called a dictionary,

239
00:16:06.075 --> 00:16:11.050
which if you have programmed before is
similar to an associative array.

240
00:16:11.050 --> 00:16:14.600
And the way you would declare these is by
using curly brackets.

241
00:16:14.600 --> 00:16:17.640
So a curly open and close bracket would

242
00:16:17.640 --> 00:16:20.780
declare it as being something being a
dictionary.

243
00:16:20.780 --> 00:16:23.640
Now the idea of dictionary is that you
have a key

244
00:16:23.640 --> 00:16:27.480
which you can define and a value which you
match it to.

245
00:16:31.640 --> 00:16:36.670
So, something like this would be a common
idea for an array,

246
00:16:37.790 --> 00:16:40.420
or for a dictionary, depending on what you
want to call it.

247
00:16:42.010 --> 00:16:44.430
So if we were to save that in Word, you'd
see

248
00:16:44.430 --> 00:16:48.900
we get the clasp of a dict, which is a
dictionary.

249
00:16:48.900 --> 00:16:52.000
And we'd get the values of two and one.

250
00:16:52.000 --> 00:16:54.580
Now, you'll realize that, you'll notice
that

251
00:16:54.580 --> 00:16:56.940
these aren't actually in the same value

252
00:16:56.940 --> 00:17:01.230
as what they are, or the same order which
they are when they're declared.

253
00:17:01.230 --> 00:17:02.400
And the reason for that is because it's

254
00:17:02.400 --> 00:17:06.570
a hashed table, and so the actual values
don't

255
00:17:06.570 --> 00:17:12.380
get stored the same way in, in which they
do, that is, in which they get declared.

256
00:17:12.380 --> 00:17:14.390
They get stored in the order in which it

257
00:17:14.390 --> 00:17:18.650
is more suitable for them to be hashed in
need.

258
00:17:18.650 --> 00:17:20.630
It's a memory order sort of thing.

259
00:17:20.630 --> 00:17:26.210
so, I won't go and try and explain how it
orders them.

260
00:17:26.210 --> 00:17:28.480
I'll just explain in fact there are ways
to sort it

261
00:17:28.480 --> 00:17:31.750
which we'll be covering later on when we
do iterations or looping.

262
00:17:33.640 --> 00:17:37.080
But if you were to have a dictionary and

263
00:17:37.080 --> 00:17:40.880
you can declare it using this sort of
idea.

264
00:17:40.880 --> 00:17:45.110
However your latest bit we have we have to
have quotes around the

265
00:17:45.110 --> 00:17:47.160
strings and we don't have quotes around

266
00:17:47.160 --> 00:17:49.400
numbers, that's, that's a very important
thing.

267
00:17:49.400 --> 00:17:51.740
If you have a quote around a number, it no
longer,

268
00:17:51.740 --> 00:17:54.330
it stays as a number, it gets converted to
a string.

269
00:17:56.030 --> 00:17:56.530
So,

270
00:17:58.460 --> 00:18:01.570
and also these can be changed around, but
the one thing you

271
00:18:01.570 --> 00:18:03.870
need to remember with dictionaries is, is,
when this is the key,

272
00:18:06.300 --> 00:18:10.150
or we also call that the index sometimes,
and this

273
00:18:10.150 --> 00:18:13.880
here is the value, which is related to the
key.

274
00:18:13.880 --> 00:18:15.800
So I could change this around to put that
as

275
00:18:15.800 --> 00:18:19.540
being five, it makes no logical sense to
do that idea.

276
00:18:19.540 --> 00:18:25.310
However, but if we were to have something
different, so you call this ID and this

277
00:18:25.310 --> 00:18:32.500
one name, I can change this to be Alex and
it would work.

278
00:18:32.500 --> 00:18:33.250
So

279
00:18:35.980 --> 00:18:39.710
when you're using dictionaries as an
associative array, the data type

280
00:18:39.710 --> 00:18:43.090
does not have to be the same within the
actual array.

281
00:18:43.090 --> 00:18:44.720
And the same with listings, it doesn't
have to

282
00:18:44.720 --> 00:18:47.070
be the type, the same type within the
list.

283
00:18:48.130 --> 00:18:49.810
Now, you may be wondering what the point
of

284
00:18:49.810 --> 00:18:55.210
having a list is, if you can have
associative array.

285
00:18:55.210 --> 00:18:59.040
And the reason why you'd use a list is
because it's actually considered faster to

286
00:18:59.040 --> 00:19:04.490
run because it gets returned in the same
order in which it gets declared at.

287
00:19:04.490 --> 00:19:08.370
So, if you were, if you knew [UNKNOWN]
location where something was,

288
00:19:08.370 --> 00:19:12.250
you'd use a list, because then you could
declare what that location is.

289
00:19:12.250 --> 00:19:16.790
Whereas using this sort of idea, you'd
need to run extra functions to find

290
00:19:16.790 --> 00:19:21.880
out the actual location of the storage, of
the piece of information that is stored.

291
00:19:24.250 --> 00:19:27.710
Okay there's also another way in which you
can declare a dictionary.

292
00:19:29.260 --> 00:19:31.230
And I'll just write that.

293
00:19:31.230 --> 00:19:35.080
And that is using the dict function.

294
00:19:36.430 --> 00:19:39.719
And the way that you do that is one is
equal to one.

295
00:19:41.280 --> 00:19:46.030
Two is equal to two, and I'll just leave
it at that.

296
00:19:46.030 --> 00:19:48.360
What you can see here, I'll just change
this as

297
00:19:54.070 --> 00:19:54.205
well.

298
00:19:54.205 --> 00:20:00.488
[SOUND] Okay if we save that now and run
that.

299
00:20:00.488 --> 00:20:03.250
You'll notice that we get the same class.

300
00:20:03.250 --> 00:20:04.520
It's another way of declaring it.

301
00:20:04.520 --> 00:20:07.490
It's just a more readable way of declaring
it.

302
00:20:07.490 --> 00:20:10.150
This can be put over multiple lines,
should you find it easier to do that.

303
00:20:11.590 --> 00:20:15.865
However, you'll also notice that the keys
no longer need to have quotes around them.

304
00:20:15.865 --> 00:20:21.142
The key gets equation [UNKNOWN]
automatically depending on, obviously data

305
00:20:21.142 --> 00:20:27.800
type gets recognized as being [INAUDIBLE]
integer or, and or a string, basically.

306
00:20:27.800 --> 00:20:32.140
And the value does still need a quote
around it.

307
00:20:32.140 --> 00:20:38.170
However, this is considerably easier to
actually write because you need to hit the

308
00:20:38.170 --> 00:20:44.170
the quote key considerably less often
which makes it faster and easier to write.

309
00:20:44.170 --> 00:20:47.900
It also makes it easier to recognize it as
well because

310
00:20:47.900 --> 00:20:50.630
it has the function of dict rather than
just curly brackets.

311
00:20:54.360 --> 00:20:58.870
A final thing in which we have to talk
about is something called a Boolean.

312
00:20:58.870 --> 00:21:03.570
Now a Boolean is a true or false that is
the two values of a Boolean.

313
00:21:09.270 --> 00:21:14.600
So if we have a Boolean equal to false,
then you'll notice

314
00:21:14.600 --> 00:21:19.060
that the class is Bool, and the value is
false, as you'd expect.

315
00:21:19.060 --> 00:21:23.490
So false and also just true are both
keywords which

316
00:21:23.490 --> 00:21:26.050
are used very, very often

317
00:21:26.050 --> 00:21:29.080
within programming languages, and
especially Python.

318
00:21:29.080 --> 00:21:33.960
You use them all the time without even
knowing it, most of, usually.

319
00:21:33.960 --> 00:21:36.710
For example, if I was to declare two
variables and have

320
00:21:36.710 --> 00:21:39.860
it as zero and one, then if I was to do

321
00:21:43.200 --> 00:21:51.170
if a is equal to, equal to b, actually I
don't need these.

322
00:21:51.170 --> 00:21:55.759
Okay, if a is equal to b, then

323
00:21:55.759 --> 00:22:01.084
print and if we do that you'll

324
00:22:01.084 --> 00:22:06.240
see that we get a Boolean of true.

325
00:22:08.150 --> 00:22:14.610
Now what you see here is that we're doing
a check of a is equal to b.

326
00:22:14.610 --> 00:22:16.960
Now a is not equal to b, and so what we're

327
00:22:16.960 --> 00:22:21.600
getting is the output here, which we can
see if we do,

328
00:22:24.360 --> 00:22:28.370
if we do else, and print false.

329
00:22:31.300 --> 00:22:33.290
That you'll see that we get the value of
false.

330
00:22:33.290 --> 00:22:36.020
And the reason for that is because we have
a is not equal

331
00:22:36.020 --> 00:22:39.990
to b because a is equal to zero and b is
equal to one.

332
00:22:39.990 --> 00:22:41.920
I should note that you can declare
multiple

333
00:22:41.920 --> 00:22:44.980
variables on each line by separating by
commas, and

334
00:22:44.980 --> 00:22:47.280
just make sure that you have the same
number

335
00:22:47.280 --> 00:22:50.340
of values on the other side, separate by
commas.

336
00:22:50.340 --> 00:22:56.280
So if I wanted to declare c, then I could
declare that as being number two there.

337
00:22:56.280 --> 00:22:59.310
And that worked just the same way.

338
00:23:01.590 --> 00:23:06.850
So, having true or false is used very
often

339
00:23:06.850 --> 00:23:12.340
within Python, and other languages, but
usually without even being recognized.

340
00:23:13.360 --> 00:23:16.780
The way in which they are used is a bit,
the the

341
00:23:16.780 --> 00:23:20.670
value is being checked as to where there
is something equal to something.

342
00:23:20.670 --> 00:23:24.810
If you're doing a double equals, which is
to check whether the values

343
00:23:24.810 --> 00:23:28.900
are the same, if you use a single equals
sign, that is to.

344
00:23:28.900 --> 00:23:32.150
Add something, to make something equal to
something, when using

345
00:23:32.150 --> 00:23:35.460
double equals signs to check whether
something is equal to something.

346
00:23:35.460 --> 00:23:38.720
So there is a big difference between
single and double equals signs,

347
00:23:40.130 --> 00:23:44.150
and if you used the single equals sign
within here it wouldn't work.

348
00:23:44.150 --> 00:23:48.890
It would just not run properly.

349
00:23:48.890 --> 00:23:52.750
So, what you need to recognize within this
is that,

350
00:23:52.750 --> 00:23:55.190
even though you have not seen the word
true at all.

351
00:23:55.190 --> 00:23:58.900
It is a Boolean expression, it is checking
whether or not

352
00:23:58.900 --> 00:24:03.680
something is true or false depending on
what keywords you're using.

353
00:24:03.680 --> 00:24:08.260
I'll get into using logical operators
later on within the course.

354
00:24:08.260 --> 00:24:14.010
However what you will see is, that this
sort of idea is happening quite often.

355
00:24:14.010 --> 00:24:16.360
And this is just a Boolean check.

356
00:24:16.360 --> 00:24:20.150
So if something doesn't happen as you'd
expect it to, there are ways

357
00:24:20.150 --> 00:24:22.770
to debug it, which again I'll be covering
later on in the course.

358
00:24:23.770 --> 00:24:28.640
Thank you for watching, this has been a
fairly long video, which I apologize for.

359
00:24:28.640 --> 00:24:33.590
However I am sure that worst, it's taking
a long time to

360
00:24:33.590 --> 00:24:36.930
get this far and we haven't, it doesn't
feel like you've done much.

361
00:24:36.930 --> 00:24:38.910
Understanding this will make the rest

362
00:24:38.910 --> 00:24:41.700
of the course considerably easier to
understand.

363
00:24:41.700 --> 00:24:44.400
Once because, once you understand data
types,

364
00:24:44.400 --> 00:24:47.740
you'll understand how things flow together
within.

365
00:24:47.740 --> 00:24:49.550
So if you are slightly confused, I might,

366
00:24:49.550 --> 00:24:52.780
I would recommend that you rewatch this
video,

367
00:24:52.780 --> 00:24:54.100
or the bits in which you're confused
within

368
00:24:54.100 --> 00:24:57.800
this video, and it will explain things to
you.

369
00:24:57.800 --> 00:24:59.910
And hopefully, once you understand them,
it will

370
00:24:59.910 --> 00:25:02.300
help you understand the rest of the
course.

371
00:25:02.300 --> 00:25:05.520
If you do find this sort of slightly
difficult to get your hands around, to get

372
00:25:05.520 --> 00:25:08.980
your mind around, and to understand,
watching the

373
00:25:08.980 --> 00:25:11.170
rest of the course might also explain this
part.

374
00:25:11.170 --> 00:25:14.660
So, it is up to you how you want to learn
this.

375
00:25:14.660 --> 00:25:18.360
However, I would recommend that you
understand this from the mental

376
00:25:18.360 --> 00:25:22.880
concept of programming before you
understand the rest of the course.

377
00:25:22.880 --> 00:25:26.343
So I'm Alex [INAUDIBLE] from
Learntorogram.tv and thanks for watching.

378
00:25:26.343 --> 00:25:31.259
[MUSIC]

